{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.1.0\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar context_1 = require(\"../context/context\");\n\nvar sortController_1 = require(\"../sortController\");\n\nvar valueService_1 = require(\"../valueService/valueService\");\n\nvar gridOptionsWrapper_1 = require(\"../gridOptionsWrapper\");\n\nvar columnController_1 = require(\"../columnController/columnController\");\n\nvar utils_1 = require(\"../utils\");\n\nvar SortService =\n/** @class */\nfunction () {\n  function SortService() {}\n\n  SortService.prototype.init = function () {\n    this.postSortFunc = this.gridOptionsWrapper.getPostSortFunc();\n  };\n\n  SortService.prototype.sort = function (sortOptions, sortActive, deltaSort, dirtyLeafNodes, changedPath, noAggregations) {\n    var _this = this;\n\n    var callback = function (rowNode) {\n      // we clear out the 'pull down open parents' first, as the values mix up the sorting\n      _this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterFilter, true); // Javascript sort is non deterministic when all the array items are equals, ie Comparator always returns 0,\n      // so to ensure the array keeps its order, add an additional sorting condition manually, in this case we\n      // are going to inspect the original array position. This is what sortedRowNodes is for.\n\n\n      if (sortActive) {\n        var sortedRowNodes = deltaSort ? _this.doDeltaSort(rowNode, sortOptions, dirtyLeafNodes, changedPath, noAggregations) : _this.doFullSort(rowNode, sortOptions);\n        rowNode.childrenAfterSort = sortedRowNodes.map(function (sorted) {\n          return sorted.rowNode;\n        });\n      } else {\n        rowNode.childrenAfterSort = rowNode.childrenAfterFilter.slice(0);\n      }\n\n      _this.updateChildIndexes(rowNode);\n\n      if (_this.postSortFunc) {\n        _this.postSortFunc(rowNode.childrenAfterSort);\n      }\n    };\n\n    changedPath.forEachChangedNodeDepthFirst(callback);\n    this.updateGroupDataForHiddenOpenParents(changedPath);\n  };\n\n  SortService.prototype.doFullSort = function (rowNode, sortOptions) {\n    var sortedRowNodes = rowNode.childrenAfterFilter.map(this.mapNodeToSortedNode.bind(this));\n    sortedRowNodes.sort(this.compareRowNodes.bind(this, sortOptions));\n    return sortedRowNodes;\n  };\n\n  SortService.prototype.mapNodeToSortedNode = function (rowNode, pos) {\n    return {\n      currentPos: pos,\n      rowNode: rowNode\n    };\n  };\n\n  SortService.prototype.doDeltaSort = function (rowNode, sortOptions, dirtyLeafNodes, changedPath, noAggregations) {\n    // clean nodes will be a list of all row nodes that remain in the set\n    // and ordered. we start with the old sorted set and take out any nodes\n    // that were removed or changed (but not added, added doesn't make sense,\n    // if a node was added, there is no way it could be here from last time).\n    var cleanNodes = rowNode.childrenAfterSort.filter(function (rowNode) {\n      // take out all nodes that were changed as part of the current transaction.\n      // a changed node could a) be in a different sort position or b) may\n      // no longer be in this set as the changed node may not pass filtering,\n      // or be in a different group.\n      var passesDirtyNodesCheck = !dirtyLeafNodes[rowNode.id]; // also remove group nodes in the changed path, as they can have different aggregate\n      // values which could impact the sort order.\n      // note: changed path is not active if a) no value columns or b) no transactions. it is never\n      // (b) in deltaSort as we only do deltaSort for transactions. for (a) if no value columns, then\n      // there is no value in the group that could of changed (ie no aggregate values)\n\n      var passesChangedPathCheck = noAggregations || changedPath.canSkip(rowNode);\n      return passesDirtyNodesCheck && passesChangedPathCheck;\n    }).map(this.mapNodeToSortedNode.bind(this)); // for fast access below, we map them\n\n    var cleanNodesMapped = {};\n    cleanNodes.forEach(function (sortedRowNode) {\n      return cleanNodesMapped[sortedRowNode.rowNode.id] = sortedRowNode.rowNode;\n    }); // these are all nodes that need to be placed\n\n    var changedNodes = rowNode.childrenAfterFilter // ignore nodes in the clean list\n    .filter(function (rowNode) {\n      return !cleanNodesMapped[rowNode.id];\n    }).map(this.mapNodeToSortedNode.bind(this)); // sort changed nodes. note that we don't need to sort cleanNodes as they are\n    // already sorted from last time.\n\n    changedNodes.sort(this.compareRowNodes.bind(this, sortOptions));\n\n    if (changedNodes.length === 0) {\n      return cleanNodes;\n    } else if (cleanNodes.length === 0) {\n      return changedNodes;\n    } else {\n      return this.mergeSortedArrays(sortOptions, cleanNodes, changedNodes);\n    }\n  }; // Merge two sorted arrays into each other\n\n\n  SortService.prototype.mergeSortedArrays = function (sortOptions, arr1, arr2) {\n    var res = [];\n    var i = 0;\n    var j = 0; // Traverse both array, adding them in order\n\n    while (i < arr1.length && j < arr2.length) {\n      // Check if current element of first\n      // array is smaller than current element\n      // of second array. If yes, store first\n      // array element and increment first array\n      // index. Otherwise do same with second array\n      var compareResult = this.compareRowNodes(sortOptions, arr1[i], arr2[j]);\n\n      if (compareResult < 0) {\n        res.push(arr1[i++]);\n      } else {\n        res.push(arr2[j++]);\n      }\n    } // add remaining from arr1\n\n\n    while (i < arr1.length) {\n      res.push(arr1[i++]);\n    } // add remaining from arr2\n\n\n    while (j < arr2.length) {\n      res.push(arr2[j++]);\n    }\n\n    return res;\n  };\n\n  SortService.prototype.compareRowNodes = function (sortOptions, sortedNodeA, sortedNodeB) {\n    var nodeA = sortedNodeA.rowNode;\n    var nodeB = sortedNodeB.rowNode; // Iterate columns, return the first that doesn't match\n\n    for (var i = 0, len = sortOptions.length; i < len; i++) {\n      var sortOption = sortOptions[i]; // let compared = compare(nodeA, nodeB, sortOption.column, sortOption.inverter === -1);\n\n      var isInverted = sortOption.inverter === -1;\n      var valueA = this.getValue(nodeA, sortOption.column);\n      var valueB = this.getValue(nodeB, sortOption.column);\n      var comparatorResult = void 0;\n\n      if (sortOption.column.getColDef().comparator) {\n        //if comparator provided, use it\n        comparatorResult = sortOption.column.getColDef().comparator(valueA, valueB, nodeA, nodeB, isInverted);\n      } else {\n        //otherwise do our own comparison\n        comparatorResult = utils_1._.defaultComparator(valueA, valueB, this.gridOptionsWrapper.isAccentedSort());\n      }\n\n      if (comparatorResult !== 0) {\n        return comparatorResult * sortOption.inverter;\n      }\n    } // All matched, we make is so that the original sort order is kept:\n\n\n    return sortedNodeA.currentPos - sortedNodeB.currentPos;\n  };\n\n  SortService.prototype.getValue = function (nodeA, column) {\n    return this.valueService.getValue(column, nodeA);\n  };\n\n  SortService.prototype.updateChildIndexes = function (rowNode) {\n    if (utils_1._.missing(rowNode.childrenAfterSort)) {\n      return;\n    }\n\n    var listToSort = rowNode.childrenAfterSort;\n\n    for (var i = 0; i < listToSort.length; i++) {\n      var child = listToSort[i];\n      var firstChild = i === 0;\n      var lastChild = i === rowNode.childrenAfterSort.length - 1;\n      child.setFirstChild(firstChild);\n      child.setLastChild(lastChild);\n      child.setChildIndex(i);\n    }\n  };\n\n  SortService.prototype.updateGroupDataForHiddenOpenParents = function (changedPath) {\n    var _this = this;\n\n    if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {\n      return;\n    } // recurse breadth first over group nodes after sort to 'pull down' group data to child groups\n\n\n    var callback = function (rowNode) {\n      _this.pullDownGroupDataForHideOpenParents(rowNode.childrenAfterSort, false);\n\n      rowNode.childrenAfterSort.forEach(function (child) {\n        if (child.hasChildren()) {\n          callback(child);\n        }\n      });\n    };\n\n    changedPath.executeFromRootNode(function (rowNode) {\n      return callback(rowNode);\n    });\n  };\n\n  SortService.prototype.pullDownGroupDataForHideOpenParents = function (rowNodes, clearOperation) {\n    var _this = this;\n\n    if (utils_1._.missing(rowNodes)) {\n      return;\n    }\n\n    if (!this.gridOptionsWrapper.isGroupHideOpenParents()) {\n      return;\n    }\n\n    rowNodes.forEach(function (childRowNode) {\n      var groupDisplayCols = _this.columnController.getGroupDisplayColumns();\n\n      groupDisplayCols.forEach(function (groupDisplayCol) {\n        var showRowGroup = groupDisplayCol.getColDef().showRowGroup;\n\n        if (typeof showRowGroup !== 'string') {\n          console.error('ag-Grid: groupHideOpenParents only works when specifying specific columns for colDef.showRowGroup');\n          return;\n        }\n\n        var displayingGroupKey = showRowGroup;\n\n        var rowGroupColumn = _this.columnController.getPrimaryColumn(displayingGroupKey);\n\n        var thisRowNodeMatches = rowGroupColumn === childRowNode.rowGroupColumn;\n\n        if (thisRowNodeMatches) {\n          return;\n        }\n\n        if (clearOperation) {\n          // if doing a clear operation, we clear down the value for every possible group column\n          childRowNode.setGroupValue(groupDisplayCol.getId(), null);\n        } else {\n          // if doing a set operation, we set only where the pull down is to occur\n          var parentToStealFrom = childRowNode.getFirstChildOfFirstChild(rowGroupColumn);\n\n          if (parentToStealFrom) {\n            childRowNode.setGroupValue(groupDisplayCol.getId(), parentToStealFrom.key);\n          }\n        }\n      });\n    });\n  };\n\n  __decorate([context_1.Autowired('sortController'), __metadata(\"design:type\", sortController_1.SortController)], SortService.prototype, \"sortController\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], SortService.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired('valueService'), __metadata(\"design:type\", valueService_1.ValueService)], SortService.prototype, \"valueService\", void 0);\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], SortService.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], SortService.prototype, \"init\", null);\n\n  SortService = __decorate([context_1.Bean('sortService')], SortService);\n  return SortService;\n}();\n\nexports.SortService = SortService;","map":null,"metadata":{},"sourceType":"script"}