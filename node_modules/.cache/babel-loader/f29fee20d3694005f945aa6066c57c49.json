{"ast":null,"code":"/**\n * ag-grid-community - Advanced Data Grid / Data Table supporting Javascript / React / AngularJS / Web Components\n * @version v21.1.0\n * @link http://www.ag-grid.com/\n * @license MIT\n */\n\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar component_1 = require(\"../../widgets/component\");\n\nvar column_1 = require(\"../../entities/column\");\n\nvar columnGroup_1 = require(\"../../entities/columnGroup\");\n\nvar columnApi_1 = require(\"../../columnController/columnApi\");\n\nvar columnController_1 = require(\"../../columnController/columnController\");\n\nvar gridOptionsWrapper_1 = require(\"../../gridOptionsWrapper\");\n\nvar horizontalResizeService_1 = require(\"../horizontalResizeService\");\n\nvar context_1 = require(\"../../context/context\");\n\nvar cssClassApplier_1 = require(\"../cssClassApplier\");\n\nvar dragAndDropService_1 = require(\"../../dragAndDrop/dragAndDropService\");\n\nvar setLeftFeature_1 = require(\"../../rendering/features/setLeftFeature\");\n\nvar gridApi_1 = require(\"../../gridApi\");\n\nvar userComponentFactory_1 = require(\"../../components/framework/userComponentFactory\");\n\nvar beans_1 = require(\"../../rendering/beans\");\n\nvar hoverFeature_1 = require(\"../hoverFeature\");\n\nvar utils_1 = require(\"../../utils\");\n\nvar HeaderGroupWrapperComp =\n/** @class */\nfunction (_super) {\n  __extends(HeaderGroupWrapperComp, _super);\n\n  function HeaderGroupWrapperComp(columnGroup, dragSourceDropTarget, pinned) {\n    var _this = _super.call(this, HeaderGroupWrapperComp.TEMPLATE) || this; // the children can change, we keep destroy functions related to listening to the children here\n\n\n    _this.childColumnsDestroyFuncs = [];\n    _this.columnGroup = columnGroup;\n    _this.dragSourceDropTarget = dragSourceDropTarget;\n    _this.pinned = pinned;\n    return _this;\n  }\n\n  HeaderGroupWrapperComp.prototype.postConstruct = function () {\n    cssClassApplier_1.CssClassApplier.addHeaderClassesFromColDef(this.getComponentHolder(), this.getGui(), this.gridOptionsWrapper, null, this.columnGroup);\n    var displayName = this.columnController.getDisplayNameForColumnGroup(this.columnGroup, 'header');\n    this.appendHeaderGroupComp(displayName);\n    this.setupResize();\n    this.addClasses();\n    this.setupWidth();\n    this.addAttributes();\n    this.setupMovingCss();\n    this.setupTooltip();\n    this.addFeature(this.getContext(), new hoverFeature_1.HoverFeature(this.columnGroup.getOriginalColumnGroup().getLeafColumns(), this.getGui()));\n    var setLeftFeature = new setLeftFeature_1.SetLeftFeature(this.columnGroup, this.getGui(), this.beans);\n    setLeftFeature.init();\n    this.addDestroyFunc(setLeftFeature.destroy.bind(setLeftFeature));\n  };\n\n  HeaderGroupWrapperComp.prototype.setupMovingCss = function () {\n    var _this = this;\n\n    var originalColumnGroup = this.columnGroup.getOriginalColumnGroup();\n    var leafColumns = originalColumnGroup.getLeafColumns();\n    leafColumns.forEach(function (col) {\n      _this.addDestroyableEventListener(col, column_1.Column.EVENT_MOVING_CHANGED, _this.onColumnMovingChanged.bind(_this));\n    });\n    this.onColumnMovingChanged();\n  };\n\n  HeaderGroupWrapperComp.prototype.getColumn = function () {\n    return this.columnGroup;\n  };\n\n  HeaderGroupWrapperComp.prototype.getComponentHolder = function () {\n    return this.columnGroup.getColGroupDef();\n  };\n\n  HeaderGroupWrapperComp.prototype.getTooltipText = function () {\n    var colGroupDef = this.getComponentHolder();\n    return colGroupDef && colGroupDef.headerTooltip;\n  };\n\n  HeaderGroupWrapperComp.prototype.setupTooltip = function () {\n    var tooltipText = this.getTooltipText();\n\n    if (tooltipText == null) {\n      return;\n    }\n\n    if (this.gridOptionsWrapper.isEnableBrowserTooltips()) {\n      this.getGui().setAttribute('title', tooltipText);\n    } else {\n      this.beans.tooltipManager.registerTooltip(this);\n    }\n  };\n\n  HeaderGroupWrapperComp.prototype.onColumnMovingChanged = function () {\n    // this function adds or removes the moving css, based on if the col is moving.\n    // this is what makes the header go dark when it is been moved (gives impression to\n    // user that the column was picked up).\n    utils_1._.addOrRemoveCssClass(this.getGui(), 'ag-header-cell-moving', this.columnGroup.isMoving());\n  };\n\n  HeaderGroupWrapperComp.prototype.addAttributes = function () {\n    this.getGui().setAttribute(\"col-id\", this.columnGroup.getUniqueId());\n  };\n\n  HeaderGroupWrapperComp.prototype.appendHeaderGroupComp = function (displayName) {\n    var _this = this;\n\n    var params = {\n      displayName: displayName,\n      columnGroup: this.columnGroup,\n      setExpanded: function (expanded) {\n        _this.columnController.setColumnGroupOpened(_this.columnGroup.getOriginalColumnGroup(), expanded, \"gridInitializing\");\n      },\n      api: this.gridApi,\n      columnApi: this.columnApi,\n      context: this.gridOptionsWrapper.getContext()\n    };\n\n    if (!displayName) {\n      var columnGroup = this.columnGroup;\n      var leafCols = columnGroup.getLeafColumns(); // find the top most column group that represents the same columns. so if we are dragging a group, we also\n      // want to visually show the parent groups dragging for the same column set. for example imaging 5 levels\n      // of grouping, with each group only containing the next group, and the last group containing three columns,\n      // then when you move any group (even the lowest level group) you are in-fact moving all the groups, as all\n      // the groups represent the same column set.\n\n      while (columnGroup.getParent() && columnGroup.getParent().getLeafColumns().length === leafCols.length) {\n        columnGroup = columnGroup.getParent();\n      }\n\n      var colGroupDef = columnGroup.getColGroupDef();\n\n      if (colGroupDef) {\n        displayName = colGroupDef.headerName;\n      }\n\n      if (!displayName) {\n        displayName = leafCols ? this.columnController.getDisplayNameForColumn(leafCols[0], 'header', true) : '';\n      }\n    }\n\n    var callback = this.afterHeaderCompCreated.bind(this, displayName);\n    this.userComponentFactory.newHeaderGroupComponent(params).then(callback);\n  };\n\n  HeaderGroupWrapperComp.prototype.afterHeaderCompCreated = function (displayName, headerGroupComp) {\n    this.appendChild(headerGroupComp);\n    this.setupMove(headerGroupComp.getGui(), displayName);\n  };\n\n  HeaderGroupWrapperComp.prototype.addClasses = function () {\n    // having different classes below allows the style to not have a bottom border\n    // on the group header, if no group is specified\n    // columnGroup.getColGroupDef\n    if (this.columnGroup.isPadding()) {\n      this.addCssClass('ag-header-group-cell-no-group');\n    } else {\n      this.addCssClass('ag-header-group-cell-with-group');\n    }\n  };\n\n  HeaderGroupWrapperComp.prototype.setupMove = function (eHeaderGroup, displayName) {\n    var _this = this;\n\n    if (!eHeaderGroup) {\n      return;\n    }\n\n    if (this.isSuppressMoving()) {\n      return;\n    }\n\n    var allLeafColumns = this.columnGroup.getOriginalColumnGroup().getLeafColumns();\n\n    if (eHeaderGroup) {\n      var dragSource_1 = {\n        type: dragAndDropService_1.DragSourceType.HeaderCell,\n        eElement: eHeaderGroup,\n        dragItemName: displayName,\n        // we add in the original group leaf columns, so we move both visible and non-visible items\n        dragItemCallback: this.getDragItemForGroup.bind(this),\n        dragSourceDropTarget: this.dragSourceDropTarget,\n        dragStarted: function () {\n          return allLeafColumns.forEach(function (col) {\n            return col.setMoving(true, \"uiColumnDragged\");\n          });\n        },\n        dragStopped: function () {\n          return allLeafColumns.forEach(function (col) {\n            return col.setMoving(false, \"uiColumnDragged\");\n          });\n        }\n      };\n      this.dragAndDropService.addDragSource(dragSource_1, true);\n      this.addDestroyFunc(function () {\n        return _this.dragAndDropService.removeDragSource(dragSource_1);\n      });\n    }\n  }; // when moving the columns, we want to move all the columns (contained within the DragItem) in this group in one go,\n  // and in the order they are currently in the screen.\n\n\n  HeaderGroupWrapperComp.prototype.getDragItemForGroup = function () {\n    var allColumnsOriginalOrder = this.columnGroup.getOriginalColumnGroup().getLeafColumns(); // capture visible state, used when re-entering grid to dictate which columns should be visible\n\n    var visibleState = {};\n    allColumnsOriginalOrder.forEach(function (column) {\n      return visibleState[column.getId()] = column.isVisible();\n    });\n    var allColumnsCurrentOrder = [];\n    this.columnController.getAllDisplayedColumns().forEach(function (column) {\n      if (allColumnsOriginalOrder.indexOf(column) >= 0) {\n        allColumnsCurrentOrder.push(column);\n\n        utils_1._.removeFromArray(allColumnsOriginalOrder, column);\n      }\n    }); // we are left with non-visible columns, stick these in at the end\n\n    allColumnsOriginalOrder.forEach(function (column) {\n      return allColumnsCurrentOrder.push(column);\n    }); // create and return dragItem\n\n    return {\n      columns: allColumnsCurrentOrder,\n      visibleState: visibleState\n    };\n  };\n\n  HeaderGroupWrapperComp.prototype.isSuppressMoving = function () {\n    // if any child is fixed, then don't allow moving\n    var childSuppressesMoving = false;\n    this.columnGroup.getLeafColumns().forEach(function (column) {\n      if (column.getColDef().suppressMovable || column.getColDef().lockPosition) {\n        childSuppressesMoving = true;\n      }\n    });\n    var result = childSuppressesMoving || this.gridOptionsWrapper.isSuppressMovableColumns();\n    return result;\n  };\n\n  HeaderGroupWrapperComp.prototype.setupWidth = function () {\n    // we need to listen to changes in child columns, as they impact our width\n    this.addListenersToChildrenColumns(); // the children belonging to this group can change, so we need to add and remove listeners as they change\n\n    this.addDestroyableEventListener(this.columnGroup, columnGroup_1.ColumnGroup.EVENT_DISPLAYED_CHILDREN_CHANGED, this.onDisplayedChildrenChanged.bind(this));\n    this.onWidthChanged(); // the child listeners are not tied to this components life-cycle, as children can get added and removed\n    // to the group - hence they are on a different life-cycle. so we must make sure the existing children\n    // listeners are removed when we finally get destroyed\n\n    this.addDestroyFunc(this.destroyListenersOnChildrenColumns.bind(this));\n  };\n\n  HeaderGroupWrapperComp.prototype.onDisplayedChildrenChanged = function () {\n    this.addListenersToChildrenColumns();\n    this.onWidthChanged();\n  };\n\n  HeaderGroupWrapperComp.prototype.addListenersToChildrenColumns = function () {\n    var _this = this; // first destroy any old listeners\n\n\n    this.destroyListenersOnChildrenColumns(); // now add new listeners to the new set of children\n\n    var widthChangedListener = this.onWidthChanged.bind(this);\n    this.columnGroup.getLeafColumns().forEach(function (column) {\n      column.addEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n      column.addEventListener(column_1.Column.EVENT_VISIBLE_CHANGED, widthChangedListener);\n\n      _this.childColumnsDestroyFuncs.push(function () {\n        column.removeEventListener(column_1.Column.EVENT_WIDTH_CHANGED, widthChangedListener);\n        column.removeEventListener(column_1.Column.EVENT_VISIBLE_CHANGED, widthChangedListener);\n      });\n    });\n  };\n\n  HeaderGroupWrapperComp.prototype.destroyListenersOnChildrenColumns = function () {\n    this.childColumnsDestroyFuncs.forEach(function (func) {\n      return func();\n    });\n    this.childColumnsDestroyFuncs = [];\n  };\n\n  HeaderGroupWrapperComp.prototype.onWidthChanged = function () {\n    this.getGui().style.width = this.columnGroup.getActualWidth() + 'px';\n  };\n\n  HeaderGroupWrapperComp.prototype.setupResize = function () {\n    var _this = this;\n\n    this.eHeaderCellResize = this.getRefElement('agResize');\n\n    if (!this.columnGroup.isResizable()) {\n      utils_1._.removeFromParent(this.eHeaderCellResize);\n\n      return;\n    }\n\n    var finishedWithResizeFunc = this.horizontalResizeService.addResizeBar({\n      eResizeBar: this.eHeaderCellResize,\n      onResizeStart: this.onResizeStart.bind(this),\n      onResizing: this.onResizing.bind(this, false),\n      onResizeEnd: this.onResizing.bind(this, true)\n    });\n    this.addDestroyFunc(finishedWithResizeFunc);\n\n    if (!this.gridOptionsWrapper.isSuppressAutoSize()) {\n      this.eHeaderCellResize.addEventListener('dblclick', function (event) {\n        // get list of all the column keys we are responsible for\n        var keys = [];\n\n        _this.columnGroup.getDisplayedLeafColumns().forEach(function (column) {\n          // not all cols in the group may be participating with auto-resize\n          if (!column.getColDef().suppressAutoSize) {\n            keys.push(column.getColId());\n          }\n        });\n\n        if (keys.length > 0) {\n          _this.columnController.autoSizeColumns(keys, \"uiColumnResized\");\n        }\n      });\n    }\n  };\n\n  HeaderGroupWrapperComp.prototype.onResizeStart = function (shiftKey) {\n    var _this = this;\n\n    var leafCols = this.columnGroup.getDisplayedLeafColumns();\n    this.resizeCols = utils_1._.filter(leafCols, function (col) {\n      return col.isResizable();\n    });\n    this.resizeStartWidth = 0;\n    this.resizeCols.forEach(function (col) {\n      return _this.resizeStartWidth += col.getActualWidth();\n    });\n    this.resizeRatios = [];\n    this.resizeCols.forEach(function (col) {\n      return _this.resizeRatios.push(col.getActualWidth() / _this.resizeStartWidth);\n    });\n    var takeFromGroup = null;\n\n    if (shiftKey) {\n      takeFromGroup = this.columnController.getDisplayedGroupAfter(this.columnGroup);\n    }\n\n    if (takeFromGroup) {\n      var takeFromLeafCols = takeFromGroup.getDisplayedLeafColumns();\n      this.resizeTakeFromCols = utils_1._.filter(takeFromLeafCols, function (col) {\n        return col.isResizable();\n      });\n      this.resizeTakeFromStartWidth = 0;\n      this.resizeTakeFromCols.forEach(function (col) {\n        return _this.resizeTakeFromStartWidth += col.getActualWidth();\n      });\n      this.resizeTakeFromRatios = [];\n      this.resizeTakeFromCols.forEach(function (col) {\n        return _this.resizeTakeFromRatios.push(col.getActualWidth() / _this.resizeTakeFromStartWidth);\n      });\n    } else {\n      this.resizeTakeFromCols = null;\n      this.resizeTakeFromStartWidth = null;\n      this.resizeTakeFromRatios = null;\n    }\n\n    utils_1._.addCssClass(this.getGui(), 'ag-column-resizing');\n  };\n\n  HeaderGroupWrapperComp.prototype.onResizing = function (finished, resizeAmount) {\n    var resizeSets = [];\n    var resizeAmountNormalised = this.normaliseDragChange(resizeAmount);\n    resizeSets.push({\n      columns: this.resizeCols,\n      ratios: this.resizeRatios,\n      width: this.resizeStartWidth + resizeAmountNormalised\n    });\n\n    if (this.resizeTakeFromCols) {\n      resizeSets.push({\n        columns: this.resizeTakeFromCols,\n        ratios: this.resizeTakeFromRatios,\n        width: this.resizeTakeFromStartWidth - resizeAmountNormalised\n      });\n    }\n\n    this.columnController.resizeColumnSets(resizeSets, finished, 'uiColumnDragged');\n\n    if (finished) {\n      utils_1._.removeCssClass(this.getGui(), 'ag-column-resizing');\n    }\n  }; // optionally inverts the drag, depending on pinned and RTL\n  // note - this method is duplicated in RenderedHeaderCell - should refactor out?\n\n\n  HeaderGroupWrapperComp.prototype.normaliseDragChange = function (dragChange) {\n    var result = dragChange;\n\n    if (this.gridOptionsWrapper.isEnableRtl()) {\n      // for RTL, dragging left makes the col bigger, except when pinning left\n      if (this.pinned !== column_1.Column.PINNED_LEFT) {\n        result *= -1;\n      }\n    } else {\n      // for LTR (ie normal), dragging left makes the col smaller, except when pinning right\n      if (this.pinned === column_1.Column.PINNED_RIGHT) {\n        result *= -1;\n      }\n    }\n\n    return result;\n  };\n\n  HeaderGroupWrapperComp.TEMPLATE = '<div class=\"ag-header-group-cell\">' + '<div ref=\"agResize\" class=\"ag-header-cell-resize\"></div>' + '</div>';\n\n  __decorate([context_1.Autowired('gridOptionsWrapper'), __metadata(\"design:type\", gridOptionsWrapper_1.GridOptionsWrapper)], HeaderGroupWrapperComp.prototype, \"gridOptionsWrapper\", void 0);\n\n  __decorate([context_1.Autowired('columnController'), __metadata(\"design:type\", columnController_1.ColumnController)], HeaderGroupWrapperComp.prototype, \"columnController\", void 0);\n\n  __decorate([context_1.Autowired('horizontalResizeService'), __metadata(\"design:type\", horizontalResizeService_1.HorizontalResizeService)], HeaderGroupWrapperComp.prototype, \"horizontalResizeService\", void 0);\n\n  __decorate([context_1.Autowired('dragAndDropService'), __metadata(\"design:type\", dragAndDropService_1.DragAndDropService)], HeaderGroupWrapperComp.prototype, \"dragAndDropService\", void 0);\n\n  __decorate([context_1.Autowired('userComponentFactory'), __metadata(\"design:type\", userComponentFactory_1.UserComponentFactory)], HeaderGroupWrapperComp.prototype, \"userComponentFactory\", void 0);\n\n  __decorate([context_1.Autowired('gridApi'), __metadata(\"design:type\", gridApi_1.GridApi)], HeaderGroupWrapperComp.prototype, \"gridApi\", void 0);\n\n  __decorate([context_1.Autowired('columnApi'), __metadata(\"design:type\", columnApi_1.ColumnApi)], HeaderGroupWrapperComp.prototype, \"columnApi\", void 0);\n\n  __decorate([context_1.Autowired('beans'), __metadata(\"design:type\", beans_1.Beans)], HeaderGroupWrapperComp.prototype, \"beans\", void 0);\n\n  __decorate([context_1.PostConstruct, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], HeaderGroupWrapperComp.prototype, \"postConstruct\", null);\n\n  return HeaderGroupWrapperComp;\n}(component_1.Component);\n\nexports.HeaderGroupWrapperComp = HeaderGroupWrapperComp;","map":null,"metadata":{},"sourceType":"script"}